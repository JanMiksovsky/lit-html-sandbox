{"version":3,"sources":["webpack:///webpack/bootstrap c1bca3c11aab3256c088","webpack:///./node_modules/lit-html/lit-html.js","webpack:///./src/mixins/helpers.js","webpack:///./src/components/TestElement2.js","webpack:///./src/mixins/AttributeMarshallingMixin.js","webpack:///./src/mixins/LitHtmlMixin.js","webpack:///./src/mixins/symbols.js","webpack:///./src/mixins/ReactiveMixin.js"],"names":["formatStyleProps","isAttribute","mergeDeep","updateProps","styleProps","attributes","Object","keys","map","key","join","attributeWhiteList","match","indexOf","output","sources","forEach","source","value","valueIsObject","Array","isArray","element","props","getAttribute","setAttribute","removeAttribute","Base","HTMLElement","TestElement","addEventListener","togglePunctuation","punctuation","state","style","assign","setState","hostProps","rootStyle","template","children","customElements","define","AttributeMarshallingMixin","attributeToPropertyNames","propertyNamesToAttributes","attributeName","oldValue","newValue","propertyName","attributeToPropertyName","attributesForClass","classFn","prototype","baseClass","getPrototypeOf","constructor","baseAttributes","observedAttributes","propertyNames","getOwnPropertyNames","setterNames","filter","getOwnPropertyDescriptor","set","propertyNameToAttribute","setterName","diff","attribute","concat","hyphenRegEx","replace","toUpperCase","uppercaseRegEx","toLowerCase","LitHtmlMixin","initializedKey","Symbol","renderingKey","child","console","log","setTimeout","render","extractContent","strings","o","Element","outerHTML","Text","textContent","toString","html","document","createElement","innerHTML","content","childNodes","Node","component","length","push","removeChild","symbols","afterEffect","applyEffect","beforeEffect","contentChanged","currentEffect","defaults","elementsWithTransitions","getItemText","goDown","goEnd","goLeft","goRight","goStart","goUp","itemAdded","itemsChanged","itemSelected","keydown","openedChanged","orientation","raiseChangeEvents","scrollTarget","showEffect","shadowCreated","ReactiveMixin","stateKey","defaultState","componentDidUpdate","Promise","resolve","then","parentNode"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"demos.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c1bca3c11aab3256c088","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nconst templates = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport function html(strings, ...values) {\n    let template = templates.get(strings);\n    if (template === undefined) {\n        template = new Template(strings);\n        templates.set(strings, template);\n    }\n    return new TemplateResult(template, values);\n}\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(template, values) {\n        this.template = template;\n        this.values = values;\n    }\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n */\nexport function render(result, container, partCallback = defaultPartCallback) {\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === result.template &&\n        instance._partCallback === partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance = new TemplateInstance(result.template, partCallback);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    let child;\n    while ((child = container.lastChild)) {\n        container.removeChild(child);\n    }\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid\n * https://github.com/PolymerLabs/lit-html/issues/62\n */\nconst exprMarker = `{{lit-${Math.random()}}}`;\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\nexport class Template {\n    constructor(strings) {\n        this.parts = [];\n        this.element = document.createElement('template');\n        this.element.innerHTML = strings.join(exprMarker);\n        const walker = document.createTreeWalker(this.element.content, 5 /* elements & text */);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        while (walker.nextNode()) {\n            index++;\n            const node = walker.currentNode;\n            if (node.nodeType === 1 /* ELEMENT_NODE */) {\n                if (!node.hasAttributes())\n                    continue;\n                const attributes = node.attributes;\n                for (let i = 0; i < attributes.length; i++) {\n                    const attribute = attributes.item(i);\n                    const attributeStrings = attribute.value.split(exprMarker);\n                    if (attributeStrings.length > 1) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute attribute\n                        const attributeString = strings[partIndex];\n                        // Trim the trailing literal value if this is an interpolation\n                        const rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);\n                        // Find the attribute name\n                        const rawName = rawNameString.match(/((?:\\w|[.\\-_$])+)=[\"']?$/)[1];\n                        this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));\n                        node.removeAttribute(attribute.name);\n                        partIndex += attributeStrings.length - 1;\n                        i--;\n                    }\n                }\n            }\n            else if (node.nodeType === 3 /* TEXT_NODE */) {\n                const strings = node.nodeValue.split(exprMarker);\n                if (strings.length > 1) {\n                    const parent = node.parentNode;\n                    const lastIndex = strings.length - 1;\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                    // We keep this current node, but reset its content to the last\n                    // literal part. We insert new literal nodes before this so that the\n                    // tree walker keeps its position correctly.\n                    node.textContent = strings[lastIndex];\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        parent.insertBefore(new Text(strings[i]), node);\n                        this.parts.push(new TemplatePart('node', index++));\n                    }\n                }\n                else if (!node.nodeValue.trim()) {\n                    nodesToRemove.push(node);\n                    index--;\n                }\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nexport const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (value != null && value.__litDirective === true) {\n        value = value(part);\n    }\n    return value === null ? undefined : value;\n};\nexport const directive = (f) => {\n    f.__litDirective = true;\n    return f;\n};\nexport class AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n    }\n    setValue(values, startIndex) {\n        const strings = this.strings;\n        let text = '';\n        for (let i = 0; i < strings.length; i++) {\n            text += strings[i];\n            if (i < strings.length - 1) {\n                const v = getValue(this, values[startIndex + i]);\n                if (v &&\n                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                    for (const t of v) {\n                        // TODO: we need to recursively call getValue into iterables...\n                        text += t;\n                    }\n                }\n                else {\n                    text += v;\n                }\n            }\n        }\n        this.element.setAttribute(this.name, text);\n    }\n}\nexport class NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === null ||\n            !(typeof value === 'object' || typeof value === 'function')) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        }\n        else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        }\n        else if (value instanceof Node) {\n            this._setNode(value);\n        }\n        else if (value.then !== undefined) {\n            this._setPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        }\n        else {\n            this._setNode(new Text(value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        let instance;\n        if (this._previousValue &&\n            this._previousValue.template === value.template) {\n            instance = this._previousValue;\n        }\n        else {\n            instance =\n                new TemplateInstance(value.template, this.instance._partCallback);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets of keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = new Text();\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        }\n        else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        value.then((v) => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n        this._previousValue = value;\n    }\n    clear(startNode = this.startNode) {\n        let node;\n        while ((node = startNode.nextSibling) !== this.endNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\nexport const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    }\n    else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, partCallback = defaultPartCallback) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            }\n            else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        const fragment = document.importNode(this.template.element.content, true);\n        if (this.template.parts.length > 0) {\n            const walker = document.createTreeWalker(fragment, 5 /* elements & text */);\n            const parts = this.template.parts;\n            let index = 0;\n            let partIndex = 0;\n            let templatePart = parts[0];\n            let node = walker.nextNode();\n            while (node != null && partIndex < parts.length) {\n                if (index === templatePart.index) {\n                    this._parts.push(this._partCallback(this, templatePart, node));\n                    templatePart = parts[++partIndex];\n                }\n                else {\n                    index++;\n                    node = walker.nextNode();\n                }\n            }\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=lit-html.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/lit-html/lit-html.js\n// module id = 0\n// module chunks = 0","export function formatStyleProps(styleProps) {\n  if (!styleProps) {\n    return '';\n  }\n  const attributes = Object.keys(styleProps).map(key => `${key}: ${styleProps[key]}`);\n  return attributes.join(';');\n}\n\n\nexport function isAttribute(key) {\n  const attributeWhiteList = [\n    'class',\n    'role'\n  ];\n  return key.match(/-/) || attributeWhiteList.indexOf(key) >= 0;\n}\n\n\nexport function mergeDeep(...sources) {\n  const output = {};\n  sources.forEach(source => {\n    if (source) {\n      Object.keys(source).forEach(key => {\n        const value = source[key];\n        const valueIsObject = typeof value === 'object' && !Array.isArray(value);\n        output[key] = valueIsObject && key in output ?\n          mergeDeep(output[key], value) :\n          value;\n      });\n    }\n  })\n  return output;\n}\n\n\nexport function updateProps(element, props) {\n  Object.keys(props).forEach(key => {\n    const value = key === 'style' ?\n      formatStyleProps(props[key]) :\n      props[key];\n    if (isAttribute(key) && element.getAttribute(key) !== value) {\n      // Update attribute\n      if (value) {\n        element.setAttribute(key, value);\n      } else {\n        element.removeAttribute(key);\n      }\n    } else if (element[key] !== value) {\n      // Update property\n      element[key] = value;\n    }\n  });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins/helpers.js","import { html } from '../../node_modules/lit-html/lit-html.js';\nimport { formatStyleProps, mergeDeep } from '../mixins/helpers.js';\nimport AttributeMarshallingMixin from '../mixins/AttributeMarshallingMixin.js';\n// import ChildrenContentMixin from '../mixins/ChildrenContentMixin.js';\nimport LitHtmlMixin from '../mixins/LitHtmlMixin.js';\nimport ReactiveMixin from '../mixins/ReactiveMixin.js';\n\n\nconst Base =\n  AttributeMarshallingMixin(\n  // ChildrenContentMixin(\n  LitHtmlMixin(\n  ReactiveMixin(\n    HTMLElement\n  )));\n\n\n/**\n * A simple web component created with a functional reactive programming (FRP)\n * style. In this approach, we track component state in a single `state` member,\n * then render that state to DOM. For that task, the component uses lit-html,\n * although other similar libraries could be used instead.\n *\n * The component itself is a trivial \"Hello, world\" element.\n */\nexport default class TestElement extends Base {\n\n  constructor() {\n    super();\n    // Sample event handler just to show we can respond to events.\n    this.addEventListener('click', event => {\n      this.togglePunctuation();\n    });\n  }\n\n  get defaultState() {\n    return Object.assign({}, super.defaultState, {\n      punctuation: '.'\n    });\n  }\n  \n  // These are properties that will be applied to the element's host.\n  // Defining them this way allows other mixins to easily contribute style,\n  // ARIA, and other attributes.\n  hostProps() {\n    const punctuation = this.state.punctuation || '';\n    return mergeDeep(super.hostProps && super.hostProps(), {\n      style: {\n        'cursor': 'pointer',\n        'font-style': punctuation.match(/!/) ? 'italic' : null,\n        '-webkit-user-select': 'none',\n        'user-select': 'none',\n      }\n    });\n  }\n  \n  // A sample property that updates component state.\n  get punctuation() {\n    return this.state.punctuation;\n  }\n  set punctuation(punctuation) {\n    this.setState({ punctuation });\n  }\n  \n  // Define a template that will be used to populate the shadow subtree.\n  // This is fairly conventional FRP stuff: map component state (`this.state`)\n  // to DOM. Here we do that via lit-html. The `LitHtmlMixin` mixin\n  // actually does the work of rendering the template initially, and whenever\n  // the state changes.\n  get template() {\n    const hostProps = this.hostProps();\n    const rootStyle = formatStyleProps(hostProps.style);\n    const template = html`\n      Hello, ${this.state.children}${this.punctuation}\n    `;\n    return template;\n  }\n\n  togglePunctuation() {\n    this.punctuation = this.punctuation === '.' ?\n      '!' :\n      '.';\n  }\n}\n\n\ncustomElements.define('test-element', TestElement);\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/TestElement2.js","// Memoized maps of attribute to property names and vice versa.\nconst attributeToPropertyNames = {};\nconst propertyNamesToAttributes = {};\n\n\nexport default function AttributeMarshallingMixin(Base) {\n  return class AttributeMarshalling extends Base {\n    /**\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n      const propertyName = attributeToPropertyName(attributeName);\n      // If the attribute name corresponds to a property name, set the property.\n      if (propertyName in this) {\n        this[propertyName] = newValue;\n      }\n    }\n\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n  }\n}\n\n\n/**\n * Return the custom attributes for the given class.\n */\nfunction attributesForClass(classFn) {\n\n  // We treat the HTMLElement base class as if it has no attributes, since we\n  // don't want to receive attributeChangedCallback for it. We'd like to do\n  // a simple check if classFn === HTMLElement, but this fails in the polyfill\n  // under IE, so we compare prototypes instead.\n  if (classFn.prototype === HTMLElement.prototype) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  // See if parent class defines observedAttributes manually.\n  let baseAttributes = baseClass.observedAttributes;\n  if (!baseAttributes) {\n    // Calculate parent class attributes ourselves.\n    baseAttributes = attributesForClass(baseClass);\n  }\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName =>\n    typeof Object.getOwnPropertyDescriptor(\n      classFn.prototype, propertyName).set === 'function');\n  const attributes = setterNames.map(setterName =>\n    propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n    baseAttributes.indexOf(attribute) < 0);\n  return baseAttributes.concat(diff);\n}\n\n/**\n * Convert hyphenated foo-bar attribute name to camel case fooBar property name.\n */\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hyphenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hyphenRegEx,\n      match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\n/**\n * Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\n */\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins/AttributeMarshallingMixin.js","import { render } from '../../node_modules/lit-html/lit-html.js';\nimport symbols from './symbols.js';\n\n\nconst initializedKey = Symbol('initialized');\nconst renderingKey = Symbol('renderingKey');\n\n\n/**\n * Mixin for rendering a component's light DOM contents using lit-html.\n */\nexport default function LitHtmlMixin(Base) {\n  return class LitHtml extends Base {\n\n    appendChild(child) {\n      if (this[renderingKey]) {\n        super.appendChild(child);\n      } else {\n        console.log(`appendChild ${child}`);\n        const children = [...this.state.children, child];\n        this.setState({ children });\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (!this[initializedKey]) {\n        setTimeout(() => {\n          this.render();\n        });\n      }\n    }\n\n    get defaultState() {\n      return Object.assign({}, super.defaultState, {\n        children: []\n      });\n    }\n\n    get innerHTML() {\n      if (this[renderingKey]) {\n        return super.innerHTML;\n      } else {\n        const strings = this.state.children.map(o =>\n          o instanceof Element ?\n            o.outerHTML :\n              o instanceof Text ?\n                o.textContent :\n                o.toString()\n        );\n        return strings.join('');\n      }\n    }\n    set innerHTML(html) {\n      if (this[renderingKey]) {\n        super.innerHTML = html;\n      } else {\n        const template = document.createElement('template');\n        template.innerHTML = html;\n        const children = [...template.content.childNodes];\n        console.log(`set innerHTML = ${children}`);\n        this.setState({ children });\n      }\n    }\n    \n    render() {\n      if (super.render) { super.render(); }\n      \n      if (!this[initializedKey]) {\n        // First call to render\n        this[initializedKey] = true;\n        const children = extractContent(this);\n        if (children) {\n          this.setState({ children });\n          return;\n        }\n      }\n      \n      // Invoke lit-html to render the shadow subtree.\n      this[renderingKey] = true;\n      render(this.template, this);\n      this[renderingKey] = false;\n      \n      // If we've created a new shadow, let the component do other\n      // initialization based on the rendered shadow tree.\n      // if (newShadow && this[symbols.shadowCreated]) {\n        //   this[symbols.shadowCreated]();\n        // }\n    }  \n  \n    get textContent() {\n      if (this[renderingKey]) {\n        return super.textContent;\n      } else {\n        const strings = this.state.children.map(o =>\n          o instanceof Node ? o.textContent : o.toString()\n        );\n        return strings.join('');\n      }\n    }\n    set textContent(textContent) {\n      if (this[renderingKey]) {\n        super.textContent = textContent;\n      } else {\n        const children = textContent.toString();\n        console.log(`set textContent = ${children}`);\n        this.setState({ children });\n      }\n    }\n\n  }\n}\n\n\nfunction extractContent(component) {\n  let content = null;\n  while (component.childNodes.length > 0) {\n    if (!content) {\n      content = [];\n    }\n    content.push(component.childNodes[0]);\n    component.removeChild(component.childNodes[0]);\n  }\n  return content;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins/LitHtmlMixin.js","// import Symbol from './Symbol.js';\n\n\n/**\n * A collection of (potentially polyfilled) `Symbol` objects for standard\n * component properties and methods.\n *\n * These `Symbol` objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these `Symbol` objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix/mixins/SingleSelectionMixin';\n *     import 'symbols' from 'elix/mixins/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * To support Internet Explorer 11, which does not have support for the\n * `Symbol` class, you can use the [Symbol](Symbol) helper, or a `Symbol`\n * polyfill of your choice.\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `afterEffect` method.\n   * \n   * This method is invoked after a visual effect has completed. Implement\n   * this method to perform any necessary cleanup.\n   * \n   * @param {string} effect - The name of the effect that has completed\n   */\n  afterEffect: Symbol('afterEffect'),\n\n  /**\n   * Symbol for the `applyEffect` method.\n   * \n   * This method is invoked to trigger the execution of a visual effect.\n   * \n   * @param {string} effect - The name of the effect to apply\n   * @returns {Promise} A Promise that resolves when the effect completes\n   */\n  applyEffect: Symbol('applyEffect'),\n\n  /**\n   * Symbol for the `beforeEffect` method.\n   * \n   * This method is invoked before a visual effect has begun. Implement this\n   * method to prepare the element for the effect.\n   * \n   * @param {string} effect - The name of the effect that has completed\n   */\n  beforeEffect: Symbol('beforeEffect'),\n\n  /**\n   * Symbols for the `content` property.\n   *\n   * This property returns the component's content -- however the component\n   * wants to define that. This could, for example, return the component's\n   * distributed children.\n   *\n   * @type {HTMLElement[]}\n   */\n  content: Symbol('content'),\n\n  /**\n   * Symbol for the `contentChanged` method.\n   *\n   * For components that define a `content` property, this method should be\n   * invoked when that property changes.\n   *\n   * @function contentChanged\n   */\n  contentChanged: Symbol('contentChanged'),\n\n  /**\n   * The name of the visual effect currently begin shown.\n   * \n   * @returns {string}\n   */\n  currentEffect: Symbol('currentEffect'),\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: Symbol('defaults'),\n\n  /**\n   * Symbol for the `elementsWithTransitions` property.\n   * \n   * A component can implement this method to indicate which element(s) have CSS\n   * transitions that will be triggered if the given effect is shown.\n   * \n   * @param {string} effect - The effect under consideration\n   * @returns {[HTMLElement]} The elements with CSS transitions\n   */\n  elementsWithTransitions: Symbol('elementsWithTransitions'),\n\n  /**\n   * Symbol for the `getItemText` method.\n   *\n   * This method can be applied to an item to return its text.\n   *\n   * @function getItemText\n   * @param {HTMLElement} item - the item to extract text from\n   * @returns {string} the text of the item\n   */\n  getItemText: Symbol('getText'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: Symbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: Symbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: Symbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: Symbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: Symbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: Symbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: Symbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization – since the items have \"changed\" from\n   * being nothing.\n   *\n   * @function itemsChanged\n   */\n  itemsChanged: Symbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: Symbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: Symbol('keydown'),\n\n  /**\n   * Symbol for the `openedChanged` method.\n   * \n   * This method is invoked when the `opened` property has changed. There are\n   * two advantages to using `openedChanged` rather than implementing a setter\n   * for the `opened` property: 1) `openedChanged` will supply the _parsed_\n   * value of the `opened` property, whereas the `opened` property might be\n   * passed a string as an attribute value, and 2) `openedChanged` only executes\n   * when the value of `opened` has actually changed.\n   * \n   * @param {boolean} opened - The new value of the `opened` property\n   */\n  openedChanged: Symbol('openedChanged'),\n\n  /**\n   * Indicates the general horizontal and/or vertical orientation of the\n   * component. This may affect both presentation and behavior (e.g., of\n   * keyboard navigation).\n   *\n   * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n   *\n   * @type {string}\n   */\n  orientation: Symbol('orientation'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. For a detailed discussion\n   * of this point, see the Gold Standard checklist item for\n   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n   *\n   * The above article describes a pattern for using a flag to track whether\n   * work is being performed in response to internal component activity, and\n   * whether the component should therefore raise property change events.\n   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n   * all Elix mixins and components. Sharing this flag ensures that internal\n   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n   * handling affected properties to raise change events.\n   *\n   * All UI event listeners (and other forms of internal handlers, such as\n   * timeouts and async network handlers) should set `raiseChangeEvents` to\n   * `true` at the start of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   * @var {boolean} raiseChangeEvents\n   */\n  raiseChangeEvents: Symbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `scrollTarget` property.\n   *\n   * This property indicates which element in a component's shadow subtree\n   * should be scrolled. [SelectionInViewMixin](SelectionInViewMixin) can use\n   * this property to determine which element should be scrolled to keep the\n   * selected item in view.\n   *\n   * @var {HTMLElement} scrollTarget\n   */\n  scrollTarget: Symbol('scrollTarget'),\n\n  /**\n   * Symbol for the `showEffect` method.\n   * \n   * This method invokes an asynchronous visual effect. It will invoke\n   * the `beforeEffect`, `applyEffect`, and `afterEffect` methods in\n   * turn. The first and last of those are synchronous, but `applyEffect`\n   * is asynchronous.\n   * \n   * @param {string} effect - The name of the effect that has completed\n   */\n  showEffect: Symbol('showEffect'),\n\n  /**\n   * Symbol for the `shadowCreated` method.\n   *\n   * This method is invoked when the component's shadow root has been attached\n   * and populated. Other code can handle this method to perform initialization\n   * that depends upon the existence of a populated shadow subtree.\n   *\n   * @function shadowCreated\n   */\n  shadowCreated: Symbol('shadowCreated'),\n\n  /**\n   * Symbol for the `template` method.\n   *\n   * This method should return a component's template.\n   *\n   * @param {string|object} [filler]\n   * @type {string|HTMLTemplateElement}\n   */\n  template: Symbol('template')\n};\n\nexport default symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins/symbols.js","const stateKey = Symbol('state');\nimport { updateProps } from '../mixins/helpers.js';\n\n\n/**\n * Mixin for managing a component's state.\n */\nexport default function ReactiveMixin(Base) {\n  return class Reactive extends Base {\n\n    constructor() {\n      super();\n      this[stateKey] = {};\n      this.setState(this.defaultState);\n    }\n\n    get defaultState() {\n      return super.defaultState || {};\n    }\n\n    render() {\n      if (super.render) { super.render(); }\n      // console.log(`ReactiveMixin: render`);\n      if (this.hostProps) {\n        const hostProps = this.hostProps();\n        updateProps(this, hostProps);\n      }\n      if (this.componentDidUpdate) {\n        Promise.resolve().then(() => {\n          this.componentDidUpdate();\n        });\n      }\n    }\n\n    setState(state) {\n      Object.assign(this[stateKey], state);\n      if (this.parentNode) {\n        this.render();\n      }\n    }\n\n    get state() {\n      return this[stateKey];\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins/ReactiveMixin.js"],"sourceRoot":""}